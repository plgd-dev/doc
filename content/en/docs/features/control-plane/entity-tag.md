---
title: 'Entity-tag (ETAG)'
description: 'What is ETAG?'
docsOthersDisplay: true
date: '2021-05-13'
categories: [features]
keywords: [twin, twin, cache, history]
weight: 31
---

An entity-tag (ETAG) serves as a resource-local identifier to distinguish between different representations of the same resource that change over time. It is generated by the server (device) providing the resource and can be created using various methods such as a version, checksum, hash, or timestamp. When an endpoint (client) receives an entity-tag, it should treat it as an opaque value without making any assumptions about its content or structure. In CoAP, the ETag is part of the [CoAP options](https://datatracker.ietf.org/doc/html/rfc7252#section-5.4) and is used to detect changes in resources. It optimizes resource serialization on the device side and resource deserialization on the client side.

{{< note >}}
For more information about ETAG, refer to the [RFC7252 Section 5.10.6](https://datatracker.ietf.org/doc/html/rfc7252#section-5.10.6).
{{< /note >}}

## IoTivity-lite

### ETAG Generation Algorithm

In IoTivity-lite, the ETAG is generated using the following algorithm:

1. Take the current time and the current global ETAG value.
2. If the current time is greater than the global ETAG value, set the current time as the new ETAG value.
3. Otherwise, increment the maximum ETAG value by one and use it as the new ETAG value for the changed resource.
4. Store the newly generated ETAG in the changed resource for future use.

By following this algorithm, the ETAG value is always **increasing and unique for each changed resource among all resources in the device**.

The global ETAG value is calculated as the maximum value among all ETAG values and the current time, plus a random value plus 1 (see `oc_etag_load_and_clear`). The time component helps reduce collisions between the ETAG values of device resources and the cached ETAG values in clients, while the random value adds uncertainty to the ETAG value. **If a collision occurs, the client will receive a response with the code `VALID`, but the resource content in the device and the client will be different.**

```c
static uint64_t g_etag;

void oc_etag_init()
{
    g_etag = oc_clock_time() + oc_random_value();
}

// Get new ETAG for changed resource
uint64_t oc_etag_get(void)
{
    uint64_t now = oc_clock_time();
    if (now > g_etag)
    {
        g_etag = now;
    }
    else
    {
        g_etag++;
    }
    return g_etag;
}

// Load ETAGs from storage and clear storage
bool oc_etag_load_and_clear()
{
    uint64_t loaded_etags[OC_MAX_APP_RESOURCES];
    bool ok = oc_etags_load(&loaded_etags);
    oc_etag_clear_storage();
    if (!ok)
    {
        return false;
    }
    uint64_t etag = oc_clock_time();
    for (int i = 0; i < num_loaded_etag; ++i)
    {
        if (etag < loaded_etags[i])
        {
            etag = loaded_etags[i];
        }
    }
    // Reinitialize global ETAG value if it can be less than loaded ETAGs
    g_etag = etag + oc_random_value() + 1;

    // Set ETAG for all resources
    for (/*resources in device*/)
    {
        if (/*ETAG is in loaded_etags*/)
        {
            oc_resource_set_etag(resource, etag);
        }
        else
        {
            oc_resource_set_etag(resource, oc_etag_get());
        }
    }
    return true;
}
```

### Updating ETAG on the Device

There are two methods for updating the ETAG when a resource changes:

- `oc_notify_observers`: Notifies all observers that the resource has changed and calls `oc_resource_update_etag`. This updates the ETAG of the resource and sends the new ETAG to the observers.
- `oc_resource_update_etag`: Updates the ETAG for non-observable resources. This is useful when periodically pulling resources from the device, where CPU usage needs to be optimized by avoiding serialization/deserialization of the resource body. The ETAG indicates that the content has been changed.

### ETAG Usage by Clients

The ETAG is sent to the client in the response, allowing the client to detect changes in the resource. If the ETAG matches the resource's latest ETAG, the device responds with a `VALID` code and an empty body without the ETAG option. If the ETAG does not match the resource's latest ETAG, the device responds with a `CONTENT` code, the content of the resource, and the latest ETAG. Subsequent observation notifications will contain the ETAG value from the resource. ETAG is set only for code `CONTENT` responses, for other responses, the ETAG is not set.

{{< note >}}
For OCF interfaces, the ETAG remains unaffected even if different representations of the resource are available, except for the batch interface (`oic.if.b`). The ETAG is specifically tied to the state of the resource itself, regardless of the interface used.
{{< /note >}}

### ETAG Batch GET/Observation for /oic/res

For the `/oic/res` resource, the ETAG is the highest ETAG value among all device resources in the collection. If multiple resources in the collection change simultaneously, the ETAG value is the highest among all changed resources. If the ETAG matches the highest ETAG value among all resources, the response is a `VALID` code and an empty body without the ETAG option. If the ETAG does not match the highest ETAG value among all resources, the response is a `CONTENT` code, the content of all resources, and the highest ETAG value among all resources.

### Loading and Dumping ETAGs

During device startup, the device developer loads the ETAGs using `oc_etag_load_and_clear` via the public API and clears the existing storage. Additionally, when properly shutting down IoTivity-lite, the ETAGs are stored in the storage using `oc_etag_dump` via the public API. Improper shutdown results in the ETAGs not being stored, leading to their absence upon restart. The device developer should call `oc_etag_load_and_clear` after creating all resources and before the first run by calling `oc_main_poll_v1`, and `oc_etag_dump` before calling `oc_main_shutdown`.

```c
int ret = oc_main_init(&handler);
...
// Create all custom resources
...
oc_etag_load_and_clear();
while (!quit)
{
    oc_clock_time_t next_event_mt = oc_main_poll_v1();
    ...
}
oc_etag_dump();
...
// Remove all custom resources
...
oc_main_shutdown();
```

### Edge Cases

1. Time Synchronization: Ensuring proper time synchronization is crucial for accurately generating the epoch time used in ETAGs. Inconsistent system clock synchronization can lead to disparities when comparing ETAG values. To address this, if the epoch time is less than the current ETAG value, the highest ETAG value plus `oc_random_value()+1` is used as a mitigation strategy.
2. Storage Failure: If storing ETAG values fails, it can result in the loss of ETAG information and inconsistencies when determining resource modification. To mitigate this issue, the device developer should verify the return value from `oc_etag_dump` to confirm the success of the operation. Storage failures often occur due to insufficient storage space.
3. ETAG Reset: In the event of a system restart or power outage, the highest ETAG value stored in memory may be lost. To mitigate this, the

 ETAG values are not loaded through `oc_etag_load_and_clear`, requiring the client to resynchronize with the device.
4. Absence of Resources after Device Reboot: ETAG values for non-existing resources are considered when calculating the highest ETAG value in `oc_etag_load_and_clear`. This ensures that ETAG values are not reused by new resources, avoiding conflicts and maintaining consistency.
5. Addition of Resources after Device Reboot: Similar to creating a new resource, the ETAG value for a newly added resource is set either as the epoch time in milliseconds (`oc_clock_time()`) or as the highest ETAG value `oc_random_value()+1` if the epoch time is less than the current highest ETAG value. This ensures proper tracking of changes for the newly added resource.

## Efficient Device Twin Synchronization

In order to monitor resource changes and determine if a resource has been modified on the device, the CoAP gateway utilizes the Entity Tag (ETAG) mechanism. The Hub maintains the ETAG for each resource along with the timestamp of the last change. It is important to note that the timestamp refers to the time when the notification arrives at the CoAP gateway.

For **Batch Observation**, the ETAG is associated with the overall state of resources. Prior to initiating resource observation, the CoAP gateway retrieves the latest ETAG among all device resources from the Hub Database. During resource observation initiation, the CoAP gateway sends the ETAG to the device. If the received ETAG matches the current state of the resources, the device responds with a code `VALID`. However, if the received ETAG does not match, the device responds with a code `CONTENT` and includes the current ETAG. Consequently, when a resource changes, the device sends the updated ETAG back to the CoAP gateway via a notification. The CoAP gateway then utilizes the `NotifyResourceChanged` command to update the ETAG for the resource in the Hub, along with the corresponding content. In cases where multiple resources change simultaneously, the CoAP gateway updates all affected resources with the same timestamp and ETAG.

{{< note >}}
To enable batch observation in IoTivity-lite, you need to activate it using the CMake option `-DOC_DISCOVERY_RESOURCE_OBSERVABLE_ENABLED=ON`.
{{< /note >}}
