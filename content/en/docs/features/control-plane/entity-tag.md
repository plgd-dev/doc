---
title: 'Entity-tag (ETAG)'
description: 'What is ETAG?'
docsOthersDisplay: true
date: '2021-05-13'
categories: [features]
keywords: [twin, twin, cache, history]
weight: 31
---

An entity-tag (ETAG) is used to identify changes of the resource that hapend over time. ETAG is generated by the resource server, in our case device, using various methods such as a version, checksum, hash or a timestamp. When the client retrieves an entity-tag, it should treat it as an opaque value without making any assumptions about its content or structure. In CoAP, the ETag is part of the [CoAP options](https://datatracker.ietf.org/doc/html/rfc7252#section-5.4) and is used to detect changes in resources. It is used optimizes the client processing time of the response from the device in case no change was detected - the ETAG wasn't changed from the last request.

{{< note >}}
For more information about ETAG, refer to the [RFC7252 Section 5.10.6](https://datatracker.ietf.org/doc/html/rfc7252#section-5.10.6).
{{< /note >}}

## IoTivity-lite

### Terms

- **ETAG**: An ETAG is an 8-byte opaque value associated with a resource state. It is generated by the device and used to detect changes in resources.
- **Global ETAG**: The Global ETAG represents the latest and highest generated ETAG value among all resources in the device. It is used to generate the next ETAG when a resource is created or modified.
- **Collision**: A collision occurs when a client has the ETAG value for a cached resource, but the device has a different ETAG associated with the resource state. Collision can happens only when time is not synchronized.
- **Random number**: it is the number in the interval `<1..1000>`.

### ETAG Generation Algorithm

In IoTivity-lite, the ETAG is generated using the following algorithm:

1. Take the current time and the current global ETAG value.
2. If the current time is greater than the global ETAG value, set the current time as the new global ETAG value.
3. Increment the global ETAG value random number and use it as the resource ETAG for the changed resource.
4. Set the generated ETAG from step 3 to the changed resource as the resource ETAG.

By following this algorithm, the ETAG value is always **increasing and unique for each changed resource among all resources in the device**.

During load, the global ETAG value is calculated as the maximum value among all ETAGs and the current time, plus a random number(see `oc_etag_load_and_clear`). The time component helps remove collisions between the ETAGs of device resources and the cached ETAGs in clients, while the random number adds uncertainty to the ETAG when the time is not synchronized.

{{< note >}}

**Collision example**: Consider a device that always sets the time to 1.1.1970 due to the lack of a real-time clock. This device has only one modifiable resource. Let's say the device is running with an updated resource that has an ETAG value of 1000, and the client also has the same ETAG value of 1000 cached. However, due to a power loss and subsequent restart (with no stored ETAGs in persistent storage), the random number generator returns 1, which is the same as the previous run. Meanwhile, another client updates the resource at the exact same time as the previous run but modifies a different property, resulting in an ETAG of 1000 for that resource.

Now, the first client, unaware of the resource change by the other client, makes a request to the resource using the cached ETAG value of 1000 from the previous run. The device responds with a code of `VALID`, indicating that the ETAG is still valid. However, the first client is unaware that the resource has been changed by another client, and the device's resource actually has same the ETAG.

{{< /note >}}

```c
static uint64_t g_etag;

static uint64_t etag_random() {
    return (oc_random_value()%1000)+1;
}

void oc_etag_init()
{
    g_etag = oc_clock_time() + etag_random();
}

// Get new ETAG for changed resource
uint64_t oc_etag_get(void)
{
    uint64_t now = oc_clock_time();
    if (now > g_etag)
    {
        g_etag = now;
    }
    g_etag = g_etag + etag_random();
    return g_etag;
}

// Load ETAGs from storage and clear storage
bool oc_etag_load_and_clear()
{
    uint64_t loaded_etags[OC_MAX_APP_RESOURCES];
    bool ok = oc_etags_load(&loaded_etags);
    oc_etag_clear_storage();
    if (!ok)
    {
        return false;
    }
    uint64_t etag = oc_clock_time();
    for (int i = 0; i < num_loaded_etag; ++i)
    {
        if (etag < loaded_etags[i])
        {
            etag = loaded_etags[i];
        }
    }
    // Reinitialize global ETAG value if it can be less than loaded ETAGs
    g_etag = etag + etag_random();

    // Set ETAG for all resources
    for (/*resources in device*/)
    {
        if (/*ETAG is in loaded_etags*/)
        {
            oc_resource_set_etag(resource, etag);
        }
        else
        {
            oc_resource_set_etag(resource, oc_etag_get());
        }
    }
    return true;
}
```

### Updating ETAG on the Device

There are two methods for updating the ETAG when a resource changes:

- `oc_notify_observers`: Notifies all observers that the resource has changed, what internally invokes `oc_resource_update_etag`.
- `oc_resource_update_etag`: Updates the ETAG without notifying observers about the content change. This could be useful for non-observable resources.

### ETAG Usage by Clients

Clients can cache the device resources as proxy to reduce network traffic, for that it need to have cached etag with GET responses. As the ETAG is encoded in each `CONTENT` response for GET command from the device, the client can check if the associated ETAG is still valid, by sending ETAG in request to the device. If the ETAG is valid the device responds with a `VALID` code without body, or a `CONTENT` code with the current ETAG and the body if the ETAG is not valid.

{{< note >}}
For OCF interfaces, the ETAG remains unaffected even if different representations of the resource are available, except for the batch interface (`oic.if.b`). The ETAG is specifically tied to the state of the resource itself, regardless of the interface used.
{{< /note >}}

### ETAG Batch interface for /oic/res

For the `/oic/res` resource, the ETAG is the highest ETAG value among all device resources in the collection. If multiple resources in the collection change simultaneously, the ETAG is the highest among all changed resources. If client make GET request with the ETAG that match the highest ETAG value among all resources, the response contains `VALID` code without body otherwise the response contains `CONTENT` code, the content of all resources, and the highest ETAG value among all resources.

### Loading and Dumping ETAGs

During device startup, the device developer loads the ETAGs using `oc_etag_load_and_clear` via the public API and clears the existing storage. Additionally, when properly shutting down IoTivity-lite, the ETAGs are stored in the storage using `oc_etag_dump` via the public API. Improper shutdown results in the ETAGs not being stored, leading to their absence upon restart. The device developer should call `oc_etag_load_and_clear` after creating all resources and before the first run by calling `oc_main_poll_v1`, and `oc_etag_dump` before calling `oc_main_shutdown`.

```c
int ret = oc_main_init(&handler);
...
// Create all custom resources
...
oc_etag_load_and_clear();
while (!quit)
{
    oc_clock_time_t next_event_mt = oc_main_poll_v1();
    ...
}
oc_etag_dump();
...
// Remove all custom resources
...
oc_main_shutdown();
```

### Edge Cases

1. **Time Synchronization**: Ensuring proper time synchronization is crucial for accurately generating the epoch time used in ETAGs. Inconsistent system clock synchronization at device can lead to ETAG conflict between the device and client. To address this, if the epoch time is less than the global ETAG, the global ETAG plus `oc_random_value()+1` is used as a mitigation strategy.
2. **Storage Failure**: If storing ETAGs fails, it can result in the loss of ETAG information and inconsistencies when determining resource modification. To mitigate this issue, the device developer should verify the return value from `oc_etag_dump` to confirm the success of the operation. Storage failures often occur due to insufficient storage space.
3. **ETAG Reset**: In the event of a system restart without dump or power outage, the global ETAG stored in memory may be lost. To mitigate this, the ETAGs are not loaded through `oc_etag_load_and_clear`, requiring the client to resynchronize with the device.
4. **Absence of Resources after Device Reboot**: ETAGs for non-existing resources are considered when calculating the global ETAG in `oc_etag_load_and_clear`. This ensures that ETAGs are not reused by new resources, avoiding conflicts and maintaining consistency.
5. **Addition of Resources after Device Reboot**: Similar to creating a new resource, the ETAG for a newly added resource is set either as the epoch time in milliseconds (`oc_clock_time()`) or as the global ETAG and incremeted by  `oc_random_value()+1`. This ensures proper tracking of changes for the newly added resource.
6. **Global ETAG overflows**: When incrementing global ETAG in some point it can overflow. In this case all resources ETAGs must reinitialized.

## Efficient Device Twin Synchronization

In order to monitor resource changes and determine if a resource has been modified on the device, the CoAP gateway utilizes the Entity Tag (ETAG) mechanism. The Hub maintains the ETAG for each resource along with the timestamp of the last change. It is important to note that the timestamp refers to the time when the notification arrives at the CoAP gateway.

For **Batch Observation**, the ETAG is associated with the overall state of resources. Prior to initiating resource observation, the CoAP gateway retrieves the latest ETAG among all device resources from the Hub Database. During resource observation initiation, the CoAP gateway sends the ETAG to the device. If the received ETAG matches the current state of the resources, the device responds with a code `VALID`. However, if the received ETAG does not match, the device responds with a code `CONTENT` and includes the current ETAG. Consequently, when a resource changes, the device sends the updated ETAG back to the CoAP gateway via a notification. The CoAP gateway transmits the ETAG together with the Content by using the `NotifyResourceChanged` method to the resource-aggregate. This command is then converted into a `ResourceChanged` event, which is saved in a database and distributed through the event bus. In cases where multiple resources change simultaneously, the CoAP gateway updates all affected resources with the same timestamp and ETAG.

The special query to the database efficiently retrieves the latest ETAG value from all device resources without loading the complete set of data. This optimized query solely focuses on performance and retrieves only the required ETAG value, excluding any additional information.

{{< note >}}
To enable batch observation in IoTivity-lite, you need to activate it using the CMake option `-DOC_DISCOVERY_RESOURCE_OBSERVABLE_ENABLED=ON`.
{{< /note >}}
