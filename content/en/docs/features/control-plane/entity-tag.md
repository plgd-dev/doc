---
title: 'Entity-tag (ETAG)'
description: 'What is ETAG?'
docsOthersDisplay: true
date: '2021-05-13'
categories: [features]
keywords: [twin, twin, cache, history]
weight: 31
---

An entity-tag is intended for use as a resource-local identifier for differentiating between representations of the same resource that vary over time. It is generated by the server(device) providing the resource, which may generate it in any number of ways including a version, checksum, hash, or time. An endpoint(client) receiving an entity-tag MUST treat it as opaque and make no assumptions about its content or structure. ETag in CoAP is part of [CoAP options](https://datatracker.ietf.org/doc/html/rfc7252#section-5.4) and is used to detect changes in resources. In device side it optimize serialization of resources and in client side it optimize deserialization of resources.

{{< note >}}
More information about ETAG can be found [here](https://datatracker.ietf.org/doc/html/rfc7252#section-5.10.6).
{{< /note >}}

## IoTivity-lite

### ETAG Generation Algorithm

For iotivity-lite, the ETAG is generated using the following algorithm as take current time and current global etag value. If current time is greater than global etag value, then the current time is used as the new etag value. Otherwise, the maximum etag value is incremented by one and used as the new etag value for the changed resource. The new generated etag is stored in the changed resource for future use. With this algorithm, the etag value is always **increasing and unique for each changed resource among all resources in the device**.

The global etag value is calculated as the maximum of all etag values and current time and then plus random value plus 1 see `oc_etag_load_and_clear`. The time is used to reduce collisions between the device resource etag and the cached etag in the client and the random value add there a uncertainty in the etag value. If collision occurs then the client will receive `VALID` but the resource content in device and client will be different.

```c
static uint64_t g_etag;

void oc_etag_init()
{
    g_etag = oc_clock_time() + oc_random_value();
}

// get new etag for changed resource
uint64_t oc_etag_get(void)
{
    uint64_t now = oc_clock_time();
    if (now > g_etag)
    {
        g_etag = now;
    }
    else
    {
        g_etag++;
    }
    return g_etag;
}

// load etags from storage and clear storage
bool oc_etag_load_and_clear() {
    uint64_t loaded_etags[OC_MAX_APP_RESOURCES];
    bool ok = oc_etags_load(&loaded_etags);
    oc_etag_clear_storage();
    if (!ok) {
        return false;
    }
    uint64_t etag = oc_clock_time();
    for (int i = 0; i < num_loaded_etag; ++i) {
        if (etag < loaded_etags[i]) {
            etag = loaded_etags[i];
        }
    }
    // reinitialize global etag value, because it can be less than loaded etags
    g_etag = etag + oc_random_value() +1;
    
    // set etag for all resources
    for (/*resources in device*/) {
        if (/*etag is in loaded_etags*/) {
            oc_resource_set_etag(resource, etag);
        } else {
            oc_resource_set_etag(resource, oc_etag_get());
        }
    }
    return true;
}
```

### Update ETAG on the device

There are two methods for updating the ETAG when a resource changes:

- `oc_notify_observers`: Notifies all observers that the resource has changed and calls `oc_resource_update_etag`. So the ETAG of the resource is updated and the new ETAG is sent to the observers.
- `oc_resource_update_etag`: Updates the ETAG for non-observable resources. This is usefull when you need to pull periodically resource from the device and you don't want to exhaust CPU usage by serializing/deserializing the body of the resource. The ETAG informs the content has been changed.

### ETAG Usage by client

Any GET or OBSERVE resource request with not valid ETAG from the client will get associated with the ETAG of the resource. The ETAG is sent to the client in the response. The client can use the ETAG to detect changes in the resource. If the ETAG is equal to the resource's latest ETAG, the device responds with a `VALID` code and an empty body without ETAG option. If the ETAG is not equal to the resource's latest ETAG, the device responds with a `CONTENT` code and the content along with the latest ETAG. For observation subsequent observation notifications will contain the ETAG value from the resource.

### ETAG Batch GET/Observation for /oic/res

For the `/oic/res` resource, the as ETAG is **the highest ETAG value among all device resources in the collection**. If multiple resources in the collection change at the same time, the ETAG value is the is the highest ETAG value among all changed resources in the collection. If ETAG is same is as highest ETAG value among all resources then the response is `VALID` code and an empty body without ETAG option. If ETAG is not same is as highest ETAG value among all resources then the response is `CONTENT` code and the content of all resources along with the highest ETAG value among all resources.

### Load and Dump ETAGs

During device startup, the device developer loads the ETAGs using `oc_etag_load_and_clear` via the public API and clears the existing storage. Additionally, when properly shutting down iotivity-lite, the ETAGs are stored in the storage using `oc_etag_dump` via the public API. Improper shutdown results in the ETAGs not being stored, leading to their absence upon restart. The device developer should call `oc_etag_load_and_clear` after creating all resources and before first run calling `oc_main_poll_v1`, and `oc_etag_dump` before calling `oc_main_shutdown`

```c
int ret = oc_main_init(&handler);
...
// create all custom resources
...
oc_etag_load_and_clear();
while (!quit) {
    oc_clock_time_t next_event_mt = oc_main_poll_v1();
    ...
}
oc_etag_dump();
...
// remove all custom resources
...
oc_main_shutdown();

```

### Edge cases

1. Time Synchronization: Ensuring proper time synchronization is crucial for accurate generation of epoch time used in ETAGs. Inconsistent system clock synchronization can lead to disparities when comparing ETAG values. To address this, if the epoch time is less than the current ETAG value, the highest ETAG value plus `oc_random_value()+1` is used as a mitigation strategy.
2. Storage Failure: If storing ETAG values fails, it can result in the loss of ETAG information and inconsistencies when determining resource modification. To mitigate this issue, the device developer should verify the return value from `oc_etag_dump` to confirm the success of the operation. Storage failures often occur due to insufficient storage space.
3. ETAG Reset: In the event of a system restart or power outage, the highest ETAG value stored in memory may be lost. To mitigate this, the ETAG values are not loaded through `oc_etag_load_and_clear`, requiring the client to resynchronize with the device.
4. Absence of Resources after Device Reboot: ETAG values for non-existing resources are considered when calculating the highest ETAG value in `oc_etag_load_and_clear`. This ensures that ETAG values are not reused by new resources, avoiding conflicts and maintaining consistency.
5. Addition of Resources after Device Reboot: Similar to creating a new resource, the ETAG value for a newly added resource is set either as the epoch time in milliseconds (`oc_clock_time()`) or as the highest ETAG value `oc_random_value()+1` if the epoch time is less than the current highest ETAG value. This ensures proper tracking of changes for the newly added resource.

## Efficient Device Twin Synchronization

The CoAP gateway employs the Entity Tag (ETAG) mechanism to monitor resource changes. An ETAG, is used to determine if a resource has been modified on the device. The Hub stores the ETAG for each resource along with the timestamp of the last change.

The CoAP gateway supports two types of resource observation:

- **Batch observation**: In this mode, the ETAG is associated with the overall state of resources. Whenever a change occurs, the Hub updates the ETAG for all affected resources with the same timestamp. Consequently, if the device goes offline and reconnects later, the Hub can send the stored latest ETAG among of the resources to the device. If ETAG is not match, then device send response with all representations of the resources with the new ETAG and the CoAP gateway updates all resources with the same ETAG. If ETAG is match, then device send response with code `VALID` and the CoAP gateway does not update the resources and set device twin to in-sync state.
  {{< note >}}
  To use this option, the device needs to support batch observation mode. For iotivity-lite, it should be enabled via the `-DOC_DISCOVERY_RESOURCE_OBSERVABLE_ENABLED=ON` cmake option.
  {{< /note >}}
- **Per resource observation**: In this mode, the ETAG for each resource needs to be stored. Similar to batch observation, when the device goes offline and reconnects, the Hub can send the corresponding stored ETAG for each observed resource but in this case ETAG is unique among resources. If ETAG is not match, then device send response with the new ETAG and the CoAP gateway updates the resource with the new ETAG. If ETAG is match, then device send response with code `VALID` and the CoAP gateway does not update the resource and set device twin to in-sync state if all resources are in-sync.

When the CoAP gateway initiates resource observation, it sends the ETAG depends on mode to the device and device sends response with code `VALID` when etag is same or `CONTENT` with the new etag. Subsequently, when the resource has changed, the device sends the updated ETAG back into the CoAP gateway in the notification. The CoAP gateway then updates the ETAG for the resource in the Hub via the `NotifyResourceChanged` with the content.
